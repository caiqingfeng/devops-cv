比较奇怪的是，算出来不太一致。

A = [  0,   0,   0,   0,   0,   0,   0,   0;
   0, 255, 255, 255,   0,   0,   0, 255;
   0, 255, 255, 255,   0,   0,   0,   0;
   0, 255, 255, 255,   0, 255,   0,   0;
   0,   0, 255,   0,   0,   0,   0,   0;
   0,   0, 255,   0,   0, 255, 255,   0;
   0, 255,   0, 255,   0,   0, 255,   0;
   0, 255, 255, 255,   0,   0,   0,   0]

K = [0, 1, 0;
 1, 0, 1;
 0, 1, 0]

R = [  0, 255, 255, 255,   0,   0,   0, 255;
 255, 255, 255, 255, 255,   0, 255,   0;
 255, 255, 255, 255, 255, 255,   0, 255;
 255, 255, 255, 255, 255,   0, 255,   0;
   0, 255, 255, 255,   0, 255, 255,   0;
   0, 255, 255, 255, 255, 255, 255, 255;
 255, 255, 255, 255, 255, 255, 255, 255;
 255, 255, 255, 255, 255,   0, 255,   0]



R = A 卷积 K

卷积的计算步骤：
（1）    卷积核绕自己的核心元素顺时针旋转180度(这个千万不要忘了)
（2）    移动卷积核的中心元素，使它位于输入图像待处理像素的正上方
（3）    在旋转后的卷积核中，将输入图像的像素值作为权重相乘
（4）    第三步各结果的和做为该输入像素对应的输出像素


把模板（n*n）放在矩阵上（中心对准要处理的元素），用模板的每个元素去乘矩阵中的的元素，累加和等于这个元素例如
R(0, 0) = K(1,1)*A(0,0)+K(1,2)*A(0,1)+K(2,1)*A(0,1)+K(2,2)*A(1,1) 
        = 0*0+1*0+1*0+0*255 
        = 0
R(0, 1) = K(1,0)*A(0,0)+K(1,1)*A(0,1)+K(1,2)*A(0,2)+
            K(2,0)*A(1,0)+K(2,1)*A(1,1)+K(2,2)*A(1,2) 
        = 1*0+0*0+1*0+
            1*0+0*255+1*255 
        = 255
R(1, 1) = 
求和：0, 0, 0;
 0, 0, 255;
 0, 255, 0
= 254

R(1, 1) = K(0,0)*A(0,0)+K(0,1)*A(0,1)+K(0,2)*A(0,2)+
            K(1,0)*A(1,0)+K(1,1)*A(1,1)+K(1,2)*A(1,2) + 
            K(2,0)*A(2,0)+K(2,1)*A(2,1)+K(2,2)*A(2,2) + 
        = 0*0+1*0+0*0+
            1*0+0*255+1*255 +
            0*0+1*255+0*255
        = 255 + 255

